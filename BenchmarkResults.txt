
*Сравнение производилось между классами TreeMap<size_t, size_t> и std::map<size_t, size_t> с 10 000 000 элементов
*Процессор: Intel Core i5-10400f Система: Windows 10
*Полный код бенчмарков находится в файле TreeBenchmarks.h

Вставка(insert)__________________________________________________________________________________________________________________

Описание алгоритма:

    Перед запуском таймера: Создается вектор v типа std::vector<std::pair<size_t, size_t>> с 10 000 000 элементов, где pair.first
    рандомно сгенирированное значение в дипазоне от 0 до 200 000 000

    После запуска таймера: Запускается цикл for(auto& elem : v); На каждой его итерации у контейнера вызывается метод insert(elem)

Результат:

	Алгоритм выполнялся 10 раз. Среднее время выполнения у TreeMap составило 14921.8 ms, у std::map 22425.6 ms
	Таким образом можно говорить, что вставка в TreeMap выполняется на 50% (в 1.5 раза) быстрее

Поиск(find)______________________________________________________________________________________________________________________

Описание алгоритма:
    
    Перед запуском таймера: Создается вектор v типа std::vector<std::pair<size_t, size_t>> с 10 000 000 элементов, где pair.first
    рандомно сгенирированное значение в дипазоне от 0 до 200 000 000. Содержимое вектора вставляется в оба контейнера. Также создается 
    вектор iv типа std::vector<size_t> со значениями от 0 до 9 999 999(индексы для v), расположенными в рандомном порядке. Также создаются 
    две переменные: size_t resCount1 = 0; size_t resCount2 = 0; Они будут хранить количество найденных элементов

    После запуска таймера: Запускается цикл for(auto elem : iv); На каждой его итерации у контейнера вызывается метод find(v[elem].first),
    а возвращаемый итератор сравнивается с end(), в случае, когда они не равны инкрементируется соответствующий resCount

Результат:

    Алгоритм выполнялся 10 раз. Среднее время выполнения у TreeMap составило 13545.5 ms, у std::map 27870.2 ms
	Таким образом можно говорить, что поиск в TreeMap выполняется на 106% (в 2.06 раза) быстрее

Удаление(erase)__________________________________________________________________________________________________________________

Описание алгоритма:
    
    Перед запуском таймера: Создается вектор v типа std::vector<std::pair<size_t, size_t>> с 10 000 000 элементов, где pair.first
    рандомно сгенирированное значение в дипазоне от 0 до 200 000 000. Содержимое вектора вставляется в оба контейнера. Также создается 
    вектор iv типа std::vector<size_t> со значениями от 0 до 9 999 999(индексы для v), расположенными в рандомном порядке. Также создаются 
    две переменные: size_t resCount1 = 0; size_t resCount2 = 0; Они будут хранить количество удаленных элементов

    После запуска таймера: Запускается цикл for(auto elem : iv); На каждой его итерации у контейнера вызывается метод erase(v[elem].first),
    а возвращаемое значение прибавляется к соответствующему resCount 

Результат:

    Алгоритм выполнялся 10 раз. Среднее время выполнения у TreeMap составило 17792.6 ms, у std::map 29104.8 ms
    Таким образом можно говорить, что удаление в TreeMap выполняется на 64% (в 1.64 раза) быстрее

Прямая итерация__________________________________________________________________________________________________________________

Описание алгоритма:

    Перед запуском таймера: Создается вектор v типа std::vector<std::pair<size_t, size_t>> с 10 000 000 элементов, где pair.first
    рандомно сгенирированное значение в дипазоне от 0 до 200 000 000. Содержимое вектора вставляется в оба контейнера(m1 и m2).
    Также создаются две переменные: size_t resCount1 = 0; size_t resCount2 = 0; Они будут хранить общую сумму ключей, 
    посещенных во время итерации элементов

    После запуска таймера: Запускается цикл for(auto& elem : m1(или m2)); На каждой его итерации, к соответствующему resCount
    прибавляется elem.first

Результат:

    Алгоритм выполнялся 10 раз. Среднее время выполнения у TreeMap составило 1408.5 ms, у std::map 1339.7 ms
    Таким образом можно говорить, что прямая итерация в TreeMap выполняется на 5% (в 1.05 раза) медленнее

Обратная итерация________________________________________________________________________________________________________________

Описание алгоритма:

    Перед запуском таймера: Создается вектор v типа std::vector<std::pair<size_t, size_t>> с 10 000 000 элементов, где pair.first
    рандомно сгенирированное значение в дипазоне от 0 до 200 000 000. Содержимое вектора вставляется в оба контейнера(m1 и m2).
    Также создаются две переменные: size_t resCount1 = 0; size_t resCount2 = 0; Они будут хранить общую сумму ключей,
    посещенных во время итерации элементов

    После запуска таймера: Запускается цикл for (auto it = m1.back(); !it.isBeforeBegin(); --it)(Для TreeMap) или 
    for (auto it = (--(m2.end())); it != m2.begin(); --it)(для std::map). На каждой его итерации, к соответствующему resCount 
    прибавляется it->first

Результат:

    Алгоритм выполнялся 10 раз. Среднее время выполнения у TreeMap составило 1316.3 ms, у std::map 2818.1 ms
    Таким образом можно говорить, что обратная итерация в TreeMap выполняется на 114% (в 2.14 раза) быстрее
